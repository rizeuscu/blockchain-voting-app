// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct BlockchainVotingAppProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for BlockchainVotingAppProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = BlockchainVotingAppProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        BlockchainVotingAppProxyMethods { wrapped_tx: tx }
    }
}

pub struct BlockchainVotingAppProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> BlockchainVotingAppProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> BlockchainVotingAppProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> BlockchainVotingAppProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn add_allowed_voter<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        election_code: Arg0,
        allowed_voter: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAllowedVoter")
            .argument(&election_code)
            .argument(&allowed_voter)
            .original_result()
    }

    pub fn create_election<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedBuffer<Env::Api>>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<u64>,
    >(
        self,
        name: Arg0,
        candidates: Arg1,
        start: Arg2,
        end: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createElection")
            .argument(&name)
            .argument(&candidates)
            .argument(&start)
            .argument(&end)
            .original_result()
    }

    pub fn vote<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        election_code: Arg0,
        voted_candidate: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("vote")
            .argument(&election_code)
            .argument(&voted_candidate)
            .original_result()
    }

    pub fn get_election_results<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        election_code: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedVec<Env::Api, VoteMetadata<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getElectionResults")
            .argument(&election_code)
            .original_result()
    }

    pub fn elections_metadata(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, ElectionMetadata<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getElectionsMetadata")
            .original_result()
    }

    pub fn votes(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, ManagedVec<Env::Api, VoteMetadata<Env::Api>>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getVotes")
            .original_result()
    }

    pub fn allowed_voters(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, ManagedVec<Env::Api, ManagedAddress<Env::Api>>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("allowedVoters")
            .original_result()
    }

    pub fn voters_voted(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, MultiValue2<BigUint<Env::Api>, ManagedVec<Env::Api, ManagedAddress<Env::Api>>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("votersVoted")
            .original_result()
    }

    pub fn code(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("code")
            .original_result()
    }
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, ManagedVecItem, Debug)]
pub struct VoteMetadata<Api>
where
    Api: ManagedTypeApi,
{
    pub candidate: ManagedBuffer<Api>,
    pub vote_count: BigUint<Api>,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, Debug)]
pub struct ElectionMetadata<Api>
where
    Api: ManagedTypeApi,
{
    pub name: ManagedBuffer<Api>,
    pub candidates: ManagedVec<Api, ManagedBuffer<Api>>,
    pub start: u64,
    pub end: u64,
}
